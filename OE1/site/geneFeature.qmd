---
title: "游빏 An치lisis gen칩mico comparativo de genes DGF-1 en *Trypanosoma cruzi*"
author: "Mathias"
format:
  html:
    theme: united
    code-fold: true
    code-link: true
    number-sections: true
    highlight-style: github
---

```{css}
#| echo: false

p {
  text-align: justify
}

```


```{r}
#| label: set global variable
#| echo: false
#| warning: false

key_name <- "DGF-1"

genome_name <- c("TriTrypDB-68_TcruziDm28c2018_Genome.fasta", "TriTrypDB-68_TcruziBrazilA4_Genome.fasta", "TriTrypDB-68_TcruziYC6_Genome.fasta", "TcDm25_TcruziTcDm25H1_Genome.fasta")


```

## Descripcion

![](https://img.itch.zone/aW1nLzE3MTEyNjE5LmdpZg==/original/2%2BYVZg.gif){style="float:right;" fig-alt="Illustration of a detective cat. Artwork by @https://shigemi.itch.io." width="301"}

En este proyecto analizo la familia g칠nica ``r key_name``, presente en m칰ltiples copias dentro del genoma de T. cruzi, el par치sito que causa la enfermedad de Chagas 游.

游댌 쯈u칠 busco?
Comprender la diversidad, evoluci칩n y funci칩n de estos genes, que podr칤an estar implicados en procesos clave como la evasi칩n inmune y la replicaci칩n. Para ello, realizo un an치lisis comparativo entre diferentes genomas de T. cruzi.

## 游빍 Materiales y M칠todos

游늭 Datos gen칩micos utilizados
Se utilizaron secuencias gen칩micas completas y anotaciones de genes de distintas cepas de *Trypanosoma cruzi*, descargadas de las bases de datos p칰blicas [**tritrydb**](https://tritrypdb.org/tritrypdb/app) y [**NCBI**](https://www.ncbi.nlm.nih.gov/). Entre los genomas analizados se incluyen:

*  *T. cruzi* Dm28c

*  *T. cruzi* BrazilA4

*  *T. cruzi* YC6

*  *T. cruzi* TcDm25 haplotipo 1 y 2

游댢 Procesamiento y an치lisis de secuencias
Para la extracci칩n, filtrado y an치lisis de los genes DGF-1 se emplearon diversas herramientas bioinform치ticas:

*  游 InfoSeq (EMBOSS): para obtener estad칤sticas b치sicas de las secuencias (longitud, contenido GC, etc.)

*  游냌 Scripts personalizados en Bash y AWK

*  游늵 R: para an치lisis comparativo, exploratorio y visualizaci칩n de resultados

  +  seqinr, Biostrings: lectura y manipulaci칩n de secuencias

  +  ggplot2, patchwork: gr치ficos y visualizaciones

  +  dplyr, tidyr: procesamiento y organizaci칩n de datos

  +  stringr, purrr: herramientas auxiliares

游늵 An치lisis realizados

*  Caracterizaci칩n de longitud y contenido GC

*  Filtrado e identificaci칩n de posibles pseudogenes

*  Mapeo de genes ``r key_name`` en los distintos cromosomas

*  An치lisis comparativo entre cepas


```{r}
#| label: load-packages
#| echo: true
#| warning: false

# Cargar las librer칤as necesarias
library(seqinr)
library(tidyverse)
library(gridExtra)
library(reactable)

```

---

## Procesamiento de los genomas

Para procesar las secuencias FASTA, se crea una funci칩n que genera un dataframe vac칤o donde se almacenar치n los elementos obtenidos a partir de una secuencia dada. Luego, se elimina la ruta del archivo para extraer el nombre del mismo. A continuaci칩n, se obtiene el identificador de cada una de las secuencias dentro del archivo FASTA, se calcula la longitud de la secuencia y el contenido de GC utilizando funciones de la biblioteca SEQINR.

```{r}
#| label: created function
#| echo: false
#| warning: false

calculate_fasta_feature <- function(fasta_files, type){
  
  data <- data.frame(file = character(), ID = character(), Length = numeric(), GC_Content = numeric(), stringsAsFactors = FALSE)

  # Leer cada archivo FASTA y calcular las m칠tricas
  for (fasta_file in fasta_files) {
    # Leer el archivo FASTA
    fasta_content <- read.fasta(fasta_file)
    
    # Nombre base del archivo
    base_name <- basename(fasta_file)
    # Expresi칩n regular para extraer las partes necesarias
    if(type == "genome"){
      extracted_names <- sub(".*_([^_]+)\\_Genome.fasta$", "\\1", base_name)
    } else if(type == "gene") {
      extracted_names <- sub(".*_([^_]+)\\.fasta$", "\\1", base_name)
      #extracted_names <- str_remove_all(extracted_names, "^.*_")  
    }

    
    # Procesar cada secuencia en el archivo FASTA
    for (sequence in fasta_content) {
      id <- attr(sequence, "name")
      length <- round(getLength(sequence), 0)
      gc_content <- round(GC(sequence), 3)
      
      # A침adir los resultados a la tabla
      data <- data %>%
        add_row(file = extracted_names, ID = id, Length = length, GC_Content = gc_content)
    }
  }
  
  return(data)

}

# function to string manipulation on sequence ID
transform_columns <- function(df, cols) {
  # Iterate over the specified columns
  for (col in cols) {
    # Replace '=' with '_'
    df[[col]] <- gsub("=", "_", df[[col]])              
    # Remove everything after ':' or ';'
    df[[col]] <- gsub("[:;].*", "", df[[col]])
    # Remove all spaces
    df[[col]] <- gsub(" ", "", df[[col]])          
  }
  return(df)  # Return the modified data frame
}


```

### Caracter칤sticas de los genomas

Se utiliza ALGO la funci칩n mencionada para extraer diversas caracter칤sticas de los genomas. Con estos datos, generamos la primera `Tabla resumen`, que agrupa los contigs de cada genoma ``r genome_name``, mostrando el  `n칰mero total de secuencias encontradas`, as칤 como la `longitud` m칤nima, media y m치xima, as칤 como el contenido de `GC` m칤nimo, medio y m치ximo.

```{r}
#| label: extract genome feature and created summary
#| echo: true
#| warning: false

# Load the table generated by the second script
genomes <- read.table("genome_gc_length.tsv", sep = "\t", header = TRUE)
# genomes <- read.csv("../output_directory/genome_gc_length.csv", sep = ",", header = TRUE)


# Crear una tabla con el conteo de secuencias por archivo
genomes_summary <- genomes %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

```

### Tabla resumen de los genomas

```{r}
#| label: summary genome feature and created summary
#| echo: false
#| warning: false


# Mostrar la tabla de conteo de secuencias
reactable(genomes_summary, highlight = TRUE)

```

### 游늳 Visualizaci칩n del Contenido de GC y Longitud de los Genomas

Se realiz칩 un an치lisis descriptivo de los genomas la visualizaci칩n del `contenido de GC (%)` y la `longitud (en pares de bases)` de las distintas cepas analizadas.

Se desarrollaron funciones en R que permiten automatizar y reutilizar el c칩digo en diferentes etapas del an치lisis. Las visualizaciones se generaron utilizando los siguientes paquetes:

*  游꿛 `ggridges`: para representar distribuciones con densidades tipo ridgeline

*  游냏 `ggbeeswarm`: para visualizar la dispersi칩n de los valores individuales sin sobreposici칩n

*  游냝 `cowplot`: para combinar m칰ltiples gr치ficos en una sola figura

::: {.panel-tabset .nav-pills}

## 游꿭 Gr치fico de Viol칤n del Contenido de GC

La funci칩n plot_violin_gc genera un gr치fico de viol칤n que muestra la distribuci칩n del contenido de GC (%) por genoma `r genome_name`.
游닍 Paquetes: ``ggplot2``, ``ggridges``, ``ggbeeswarm``.


```{r}
#| label: plotting-genome-gc
#| fig-cap: "Secuencias por genoma y contenido GC."
#| echo: true
#| warning: false
#| layout: [[100]]

library(ggridges)
library(ggbeeswarm)
library(cowplot)

genomes$Length <- as.numeric((format(genomes$Length, scientific = TRUE))) # Changed format

# Inspired by http://tom-e-white.com/datavision/05-genome-size.html domain of https://github.com/tomwhite

plot_violin_gc <- function(data, plot_title, y_label) {
  # Sorting data
  data$file <- factor(data$file, levels = sort(unique(data$file)))

  count_data <- data %>%
    group_by(file) %>%
    summarise(count = n(), .groups = "drop")
  
  ggplot(data, aes(x = file, y = GC_Content, fill = file)) +
    geom_violin(alpha = 0.7, width = 0.5, show.legend = FALSE) + 
    geom_boxplot(width = 0.1, fill = "white", alpha = 0.3, show.legend = FALSE) +
    scale_fill_brewer(palette = "Dark2") +
    
    geom_text(data = count_data,
              aes(x = file, y = max(data$GC_Content, na.rm = TRUE) * 1.05, 
                  label = paste0(count)),
              vjust = 0, color = "black", size = 3.5) +
    
    labs(
      title = plot_title,
      y = y_label#,
      #caption = "Data source: Facultad de Ciencias, Udelar"
    ) +
    theme_minimal_vgrid() + 
    theme(
      axis.line.y = element_blank(),
      axis.ticks.y = element_blank(),
      plot.margin = margin(5.5, 5.5, 5.5, 5.5, "pt")
    ) +
    scale_y_continuous(expand = expansion(mult = c(0.05, 0.15)))
}

# Function plot_violin_gc call
plot_violin_gc(
  data = genomes, 
  plot_title = "Genome GC", 
  y_label = "GC Content"
)

```

## 游늺 Gr치fico de Viol칤n de la Longitud Gen칩mica

La funci칩n `plot_violin_length` genera un gr치fico de viol칤n que muestra la distribuci칩n de longitudes de secuencias en los genomas `r genome_name`.
游닍 Paquetes: ``ggplot2``, ``ggridges``, ``ggbeeswarm``.


```{r}
#| label: plotting-genome-length
#| fig-cap: "Secuencias por genoma y contenido GC."
#| echo: true
#| warning: false
#| layout: [[100]]

plot_violin_length <- function(data, type, plot_title, x_label) {
  set.seed(12345)
  # Sorting data
  data$file <- factor(data$file, levels = sort(unique(data$file)))

  plot_data <- data %>%
    group_by(file) %>%
    mutate(count = n(),
           median_length = median(Length)) %>%
    ungroup() #%>%
    # mutate(file = reorder(file, -median_length))
  
  label_data <- plot_data %>%
    distinct(file, .keep_all = TRUE)
  
  p <- ggplot(plot_data, aes(Length, file, color = file)) +
    geom_quasirandom(groupOnX = FALSE, show.legend = FALSE, size = 1, dodge.width = 0.9, alpha = 0.4) +
    labs(
      title = plot_title,
      x = x_label#,
      #caption = "Data source: Facultad de Ciencias, Udelar"
    ) +
    theme_minimal_vgrid() + 
    theme(
      axis.title.y = element_blank(),
      axis.line.y = element_blank(),
      axis.ticks.y = element_blank(),
      plot.margin = margin(5.5, 40, 5.5, 5.5, "pt")
    ) +
    scale_color_brewer(palette = "Dark2") +
    
    geom_text(data = label_data,
              aes(x = Inf, y = file, label = paste0(count)),
              hjust = -0.2, color = "black", size = 3.5,
              position = position_nudge(y = 0)) +

    coord_cartesian(clip = "off")

  if (type == "genome") {
    p <- p + scale_x_log10(
      breaks = c(10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8, 10^9, 10^10),
      labels = scales::trans_format("log10", scales::math_format(10^.x))
    )
  } else {
    p <- p + scale_x_continuous(expand = expansion(mult = c(0.05, 0.2)))
  }

  return(p)
}

# Function plot_violin_length call
plot_violin_length(
  data = genomes,
  "genome", 
  plot_title = "Genome size", 
  x_label = "Number of base pairs"
)

```

:::

---

## 游늳 Visualizaci칩n del Contenido de GC y Longitud de las secuencias codificantes de cada genoma

Se realiz칩 un an치lisis descriptivo de las secuencias codificantes, la visualizaci칩n del `contenido de GC (%)` y la `longitud (en pares de bases)` de las distintas cepas analizadas.

游늵 Tambien, se construye una tabla resumen por genoma ``r genome_name``, que incluye los valores m칤nimos, medios y m치ximos tanto de la longitud como del contenido de GC.

```{r}
#| label: extract all coding protein feature and created summary
#| echo: true
#| warning: false

# Load the table generated by the second script
all_code_prot_data <- read.table("all_code_protein_gc_length.tsv", sep = "\t", header = TRUE)
# all_code_prot_data <- read.csv("../output_directory/all_code_protein_gc_length.csv", sep = ",", header = TRUE)

# Crear una tabla con el conteo de secuencias por archivo
all_code_prot_summary <- all_code_prot_data %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

```

### Tabla resumen de secuencias codificantes por genoma

```{r}
#| label: created summary all coding protein 
#| echo: false
#| warning: false


# Mostrar la tabla de conteo de secuencias
reactable(all_code_prot_summary, highlight = TRUE)

```


::: {.panel-tabset .nav-pills}

## 游꿭 Gr치fico de Viol칤n del Contenido de GC

Reutilizamos la funci칩n plot_violin_gc genera un gr치fico de viol칤n que muestra la distribuci칩n del contenido de GC (%) por genoma `r genome_name`.
游닍 Paquetes: ``ggplot2``, ``ggridges``, ``ggbeeswarm``.


```{r}
#| label: plotting-gc all coding protein
#| fig-cap: "Secuencias por genoma y contenido GC."
#| echo: true
#| warning: false
#| layout: [[100]]

# Function plot_violin_gc call
plot_violin_gc(
  data = all_code_prot_data, 
  plot_title = "Coding sequence GC", 
  y_label = "GC Content"
)

```

## 游늺 Gr치fico de Viol칤n de la Longitud de secuencia

Reutilizamos la funci칩n `plot_violin_length` que genera un gr치fico de viol칤n que muestra la distribuci칩n de longitudes de secuencias en los genomas `r genome_name`.
游닍 Paquetes: ``ggplot2``, ``ggridges``, ``ggbeeswarm``.

```{r}
#| label: plotting-length all coding protein
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: true
#| warning: false
#| layout: [[100]]

# Function plot_violin_length call
plot_violin_length(
  data = all_code_prot_data,
  "genome", 
  plot_title = "coding sequence size", 
  x_label = "Number of base pairs"
)

```

:::

-----


## Procesamiento de las secuencias ``r key_name``

La funci칩n  ``calculate_fasta_feature`` se usa para calcular para cada secuencia el contenido de `GC` y la `longitud (pb)`  de ``r key_name``. 
Se crea una `tabla resumen`, que agrupa las secuencias por cada genoma ``r genome_name``, mostrando el  ``r key_name``, as칤 como la `longitud` m칤nima, media y m치xima, as칤 como el contenido de `GC` m칤nimo, medio y m치ximo.


```{r}
#| label: extract and summary data of key_name
#| echo: true
#| warning: false

target_protein <- read.table("all_annotate_gene_gc_length.tsv", sep = "\t", header = TRUE)

# Crear una tabla con el conteo de secuencias por archivo
file_sequence_counts <- target_protein %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(file_sequence_counts, highlight = TRUE)

```

### Visualizaci칩n de la Longitud y Contenido de GC de ``r key_name``

Se generan gr치ficos que representan el `contenido de GC` y la `longitud` de cada secuencia de ``r key_name``. 
En esta seccion reutilizaremos parte del codigo escrito llamando a las funciones que crean los plot de `GC` y de `longitud` de las secuencias.

::: {.panel-tabset .nav-pills}

## GC

Se usa la funcion `plot_violin_gc`, dando lugar a un gr치fico viol칤n que muestra la distribuci칩n del contenido de GC en distintos genomas de las secuencias ``r key_name``.


```{r}
#| label: plotting-gc
#| fig-cap: "Secuencias por genoma y contenido GC."
#| echo: true
#| warning: false
#| layout: [[100]]

var_title_gc <- paste0(key_name," GC")

# Function plot_violin_gc call
plot_violin_gc(
  data = target_protein, 
  plot_title = var_title_gc, 
  y_label = "GC Content"
)

```

## Length

Se usa la funci칩n previamente empleada para graficar la distribuci칩n del genoma, pero esta vez generamos un gr치fico que muestra la distribuci칩n de las longitudes de las distintas secuencias de ``r key_name``, correspondientes a cada genoma.

```{r}
#| label: plotting-length
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: true
#| warning: false
#| layout: [[100]]

var_title <- paste0(key_name," size")

# Function plot_violin_length call
plot_violin_length(
  data = target_protein,
  "gene", 
  plot_title = var_title, 
  x_label = "Number of base pairs"
)

```

:::

-----

## Filtrado de las secuencias de `r key_name` por el largo

Se filtran las secuencias de `r key_name` de acuerdo a un largo m칤nimo (9900 pb). 
Las secuencias menores a este minimo se descartaran para este analisis inicial, y ser치n estudiadas para determinar si son pseudogenes.

### Resumen de Informaci칩n de `r key_name` completas en cada genoma (filtradas por largo)

Se genera una tabla con las estad칤stias descriptivas de las `r key_name` completas

```{r}
#| label: summary-info_higher
#| echo: false
#| warning: false

target_protein_high <- read.table("all_high_gene_gc_length.tsv", sep = "\t", header = TRUE)

## NEED DEBUG HIGH and LOW
# Crear una tabla con el conteo de secuencias por archivo
file_sequence_counts <- target_protein_high %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(file_sequence_counts, highlight = TRUE)

```


### Visualizaci칩n de la Longitud y Contenido de GC de ``r key_name`` completas

Se representan el `contenido de GC` y la `longitud` de cada secuencia de ``r key_name`` completas (filtrada por un `largo minimo`). 

::: {.panel-tabset .nav-pills}

## GC

Se usa la funcion `plot_violin_gc`, para representar la distribuci칩n del contenido de GC en distintos genomas de las secuencias ``r key_name`` filtradas por un largo minimo.

```{r}
#| label: plotting-GC-filter
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: false
#| warning: false
#| layout: [[100]]

var_filter_gc <- paste0("Filter ", key_name, " GC")

# Function plot_violin_gc call
plot_violin_gc(
  data = target_protein_high, 
  plot_title = var_filter_gc, 
  y_label = "GC Content"
)

# violin_plot(filter_data_higher, "file", "GC_Content", 4, 2, "Archivo", "Longitud")

```

## Length

Se usa la funci칩n `plot_violin_length` para representar distribuci칩n de las secuencias ``r key_name`` filtradas.

```{r}
#| label: plotting-length-filter
#| fig-cap: "Secuencias por genoma y largo total de la secuencia."
#| echo: false
#| warning: false
#| layout: [[100]]

var_length_filter <- paste0( "Filter ",key_name," size")

# Function plot_violin_length call
plot_violin_length(
  data = target_protein_high,
  "gene", 
  plot_title = var_length_filter, 
  x_label = "Number of base pairs"
)

```

:::

---

## Resumen de Informaci칩n de secuencias anotadas como ``r key_name`` menores al largo minimo establecido

Se crea una nueva tabla resumen a partir de las secuencias que se descartaran por no cumplir con el minimo de largo establecido.


```{r}
#| label: summary-info-smaller
#| echo: false
#| warning: false

target_protein_low <- read.table("all_low_gene_gc_length.tsv", sep = "\t", header = TRUE)

# Crear una tabla con el conteo de secuencias por archivo
file_sequence_counts <- target_protein_low %>%
  group_by(file) %>%
  summarise(Total_Sequences = n(),
            min_length = min(Length),
            mean_length = round(mean(Length), 0),
            max_length = max(Length),
            min_gc = min(GC_Content),
            mean_gc = round(mean(GC_Content), 3),
            max_gc = max(GC_Content))

# Mostrar la tabla de conteo de secuencias
reactable(file_sequence_counts, highlight = TRUE)

```


---

## Caracterizacion de los nuevos genes ``r key_name`` anotados


```{r}
#| label: new gene
#| echo: true
#| warning: false

# Load the table generated by the second script
new_gene_annotate <- read.table("new_gene_length_gc.tsv", sep = "\t", header = TRUE)
# all_code_prot_data <- read.csv("../output_directory/all_code_protein_gc_length.csv", sep = ",", header = TRUE)

# Crear una tabla con el conteo de secuencias por archivo
new_gene_annotatet_summary <- new_gene_annotate %>%
  group_by(filename) %>%
  summarise(Total_Sequences = n(),
            min_length = min(length),
            mean_length = round(mean(length), 0),
            max_length = max(length),
            min_gc = min(gc_content),
            mean_gc = round(mean(gc_content), 3),
            max_gc = max(gc_content))

```


```{r}
#| label: summary genome feature and created summary new gene
#| echo: false
#| warning: false


# Mostrar la tabla de conteo de secuencias
# reactable(new_gene_annotatet_summary, highlight = TRUE)

```

### Visualizaci칩n de la Longitud y Contenido de GC de el total de los nuevos genes de``r key_name``

Se generan gr치ficos que representan el `contenido de GC` y la `longitud` de cada secuencia de ``r key_name`` re anotadas. 
En esta seccion reutilizaremos parte del codigo escrito llamando a las funciones que crean los plot de `GC` y de `longitud` de las secuencias.

::: {.panel-tabset .nav-pills}

## GC

Se usa la funcion `plot_violin_gc`, dando lugar a un gr치fico viol칤n que muestra la distribuci칩n del contenido de GC en distintos genomas de las secuencias ``r key_name``.


```{r}
#| label: plotting-gc re annotate
#| fig-cap: "Secuencias por genoma y contenido GC re anotadas"
#| echo: true
#| warning: false
#| layout: [[100]]

total_gene_annotate <- read.table("total_gene_length_gc.tsv", sep = "\t", header = TRUE)

# total_gene_annotatet_summary <- total_gene_annotate %>%
#   group_by(file) %>%
#   summarise(Total_Sequences = n(),
#             min_length = min(Length),
#             mean_length = round(mean(Length), 0),
#             max_length = max(Length),
#             min_gc = min(GC_Content),
#             mean_gc = round(mean(GC_Content), 3),
#             max_gc = max(GC_Content))

var_title_gc <- paste0(key_name," GC")

# Function plot_violin_gc call
plot_violin_gc(
  data = total_gene_annotate, 
  plot_title = var_title_gc, 
  y_label = "GC Content"
)

```

## Length

Se usa la funci칩n previamente empleada para graficar la distribuci칩n del genoma, pero esta vez generamos un gr치fico que muestra la distribuci칩n de las longitudes de las distintas secuencias de ``r key_name``, correspondientes a cada genoma.

```{r}
#| label: plotting-length re annotate
#| fig-cap: "Secuencias por genoma y largo total de la secuencia re anotadas"
#| echo: true
#| warning: false
#| layout: [[100]]

var_title <- paste0(key_name," size")

# Function plot_violin_length call
plot_violin_length(
  data = total_gene_annotate,
  "gene", 
  plot_title = var_title, 
  x_label = "Number of base pairs"
)

```

:::
